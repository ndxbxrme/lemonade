// Generated by CoffeeScript 2.5.1
(function() {
  var Waveform;

  Waveform = function(audio) {
    var buffer, canvas, channels, fileName, frequencyData, pitchData, regions, rmsData, source, view;
    buffer = null;
    canvas = null;
    channels = [];
    regions = [];
    frequencyData = [];
    rmsData = [];
    pitchData = null;
    source = null;
    fileName = '';
    view = {
      start: 0,
      stop: 1
    };
    return {
      normalize: function(threshold) {
        var c, data, factor, i, largestVal, results;
        largestVal = 0;
        data = new Float32Array(buffer.length);
        c = 0;
        while (c < buffer.numberOfChannels) {
          buffer.copyFromChannel(data, c);
          i = 0;
          while (i < buffer.length) {
            largestVal = Math.max(largestVal, Math.abs(data[i]));
            i++;
          }
          c++;
        }
        factor = (threshold || 0.8) / largestVal;
        c = 0;
        results = [];
        while (c < buffer.numberOfChannels) {
          buffer.copyFromChannel(data, c);
          i = 0;
          while (i < buffer.length) {
            data[i] = data[i] * factor;
            i++;
          }
          buffer.copyToChannel(data, c);
          results.push(c++);
        }
        return results;
      },
      trim: function() {
        var c, data, end, i, results, start, trimEnd, trimStart;
        trimStart = buffer.length;
        trimEnd = 0;
        data = [];
        c = 0;
        while (c < buffer.numberOfChannels) {
          data[c] = new Float32Array(buffer.length);
          buffer.copyFromChannel(data[c], c);
          i = 0;
          start = 0;
          end = 0;
          while (i < data[c].length) {
            if (data[c][i] && data[c][i] > 0.01) {
              if (!start) {
                start = i;
              }
              end = i;
            }
            i++;
          }
          trimStart = Math.min(trimStart, start);
          trimEnd = Math.max(trimEnd, end);
          c++;
        }
        buffer = audio.createBuffer(data.length, trimEnd - trimStart, audio.sampleRate);
        c = 0;
        results = [];
        while (c < buffer.numberOfChannels) {
          buffer.copyToChannel(data[c].slice(trimStart, trimEnd), c);
          results.push(c++);
        }
        return results;
      },
      topDeck: function() {
        var b, bit, bits, c, current, data, i, j, k, len, len1, now, ref, ref1, results;
        c = 0;
        data = new Float32Array(buffer.length);
        results = [];
        while (c < buffer.numberOfChannels) {
          buffer.copyFromChannel(data, c);
          i = 0;
          bits = {
            tops: [],
            bottoms: [],
            nothing: []
          };
          current = [];
          now = 'nothing';
          while (i < buffer.length) {
            if (data[i] >= 0) {
              if (now !== 'tops') {
                bits[now].push(current);
                current = [];
                now = 'tops';
              }
            }
            if (data[i] < 0) {
              if (now !== 'bottoms') {
                bits[now].push(current);
                current = [];
                now = 'bottoms';
              }
            }
            current.push(data[i]);
            i++;
          }
          bits[now].push(current);
          bits.bottoms = bits.bottoms.reverse();
          i = 0;
          b = 0;
          while (b < bits.tops.length) {
            if (bits.tops[b]) {
              ref = bits.tops[b];
              for (j = 0, len = ref.length; j < len; j++) {
                bit = ref[j];
                data[i++] = bit;
              }
            }
            if (bits.bottoms[b]) {
              ref1 = bits.bottoms[b];
              for (k = 0, len1 = ref1.length; k < len1; k++) {
                bit = ref1[k];
                data[i++] = bit;
              }
            }
            b++;
          }
          buffer.copyToChannel(data, c);
          results.push(c++);
        }
        return results;
      },
      onlyTops: function() {
        var b, bit, bits, c, current, data, i, j, k, len, len1, now, ref, ref1, results;
        c = 0;
        data = new Float32Array(buffer.length);
        results = [];
        while (c < buffer.numberOfChannels) {
          buffer.copyFromChannel(data, c);
          i = 0;
          bits = {
            tops: [],
            bottoms: [],
            nothing: []
          };
          current = [];
          now = 'nothing';
          while (i < buffer.length) {
            if (data[i] >= 0) {
              if (now !== 'tops') {
                bits[now].push(current);
                current = [];
                now = 'tops';
              }
            }
            if (data[i] < 0) {
              if (now !== 'bottoms') {
                bits[now].push(current);
                current = [];
                now = 'bottoms';
              }
            }
            current.push(data[i]);
            i++;
          }
          bits[now].push(current);
          bits.bottoms = bits.bottoms.reverse();
          i = 0;
          b = 0;
          while (b < bits.tops.length) {
            if (bits.tops[b]) {
              ref = bits.tops[b];
              for (j = 0, len = ref.length; j < len; j++) {
                bit = ref[j];
                data[i++] = bit;
              }
            }
            if (bits.bottoms[b]) {
              ref1 = bits.tops[b].reverse();
              for (k = 0, len1 = ref1.length; k < len1; k++) {
                bit = ref1[k];
                data[i++] = -bit;
              }
            }
            b++;
          }
          buffer.copyToChannel(data, c);
          results.push(c++);
        }
        return results;
      },
      analyze: function(minLength, threshold, release, ratio) {
        return new Promise(function(resolve) {
          var compressor, data, lastDir, lastPosition, lastReduction, offline, position, processor, rms, stride;
          stride = 256;
          frequencyData = [];
          rmsData = new Array(buffer.numberOfChannels).fill([]);
          rms = require('./rms.coffee')(0.2, 'friction', 0.5, 'friction', 1);
          offline = new OfflineAudioContext(buffer.numberOfChannels, buffer.length, buffer.sampleRate);
          //analyzer = offline.createAnalyser()
          processor = offline.createScriptProcessor(stride, buffer.numberOfChannels, buffer.numberOfChannels);
          compressor = offline.createDynamicsCompressor();
          source = offline.createBufferSource();
          //source.connect analyzer
          source.connect(compressor);
          compressor.connect(processor);
          //analyzer.fftSize = 256
          //analyzer.minDecibels = -90
          //analyzer.maxDecibels = -10
          //aBufLength = analyzer.frequencyBinCount
          compressor.threshold.value = threshold || -50;
          compressor.release.value = release || 1;
          compressor.ratio.value = ratio || 20;
          processor.connect(offline.destination);
          lastReduction = 0;
          lastPosition = 0;
          lastDir = 'nothing';
          position = 0;
          data = new Array(buffer.numberOfChannels);
          processor.onaudioprocess = function(e) {
            var c, dir;
            c = 0;
            while (c < buffer.numberOfChannels) {
              data[c] = e.inputBuffer.getChannelData(c);
              rmsData[c].push(rms.process(data[c]));
              c++;
            }
            //dataArray = new Uint8Array aBufLength
            //analyzer.getByteFrequencyData dataArray
            //frequencyData.push dataArray
            if (compressor.reduction <= lastReduction) {
              dir = 'down';
            } else {
              dir = 'up';
            }
            if (dir === 'up' && lastDir !== 'up') {
              if (position - lastPosition > (minLength || 4000)) {
                regions.push(position);
              }
              lastPosition = position;
            }
            lastDir = dir;
            lastReduction = compressor.reduction;
            return position += stride;
          };
          offline.oncomplete = function() {
            var lastRegion;
            regions.push(buffer.length);
            lastRegion = -1;
            regions = regions.map(function(item) {
              var start;
              start = lastRegion + 1;
              lastRegion = item;
              return {
                start: start,
                end: lastRegion
              };
            });
            return resolve(null);
          };
          source.buffer = buffer;
          source.start(0);
          return offline.startRendering();
        });
      },
      pitchDetect: function() {
        var Pitchfinder, detectors;
        Pitchfinder = require('pitchfinder');
        detectors = {
          YIN: Pitchfinder.YIN(),
          AMDF: Pitchfinder.AMDF(),
          DynamicWavelet: Pitchfinder.DynamicWavelet()
        };
        //detectPitch.sampleRate = audio.sampleRate
        return pitchData = Pitchfinder.default.frequencies([detectors.YIN, detectors.AMDF, detectors.DynamicWavelet], buffer.getChannelData(0), {
          sampleRate: audio.sampleRate
        });
      },
      renderOscillator: function(myosc, length) {
        return new Promise(function(resolve) {
          var c, data, numberOfChannels, offline, osc, position, processor, stride;
          numberOfChannels = 1;
          stride = 256;
          offline = new OfflineAudioContext(numberOfChannels, length + 1, audio.sampleRate);
          processor = offline.createScriptProcessor(stride, numberOfChannels, numberOfChannels);
          osc = myosc(offline);
          osc.connect(processor);
          processor.connect(offline.destination);
          channels = [];
          data = [];
          c = 0;
          while (c++ < numberOfChannels) {
            channels.push(new Float32Array(length));
            data.push(new Float32Array(stride));
          }
          position = 0;
          processor.onaudioprocess = function(e) {
            var i, results;
            c = 0;
            while (c < numberOfChannels) {
              data[c] = e.inputBuffer.getChannelData(c);
              c++;
            }
            i = 0;
            results = [];
            while (i < data[0].length) {
              c = 0;
              while (c < numberOfChannels) {
                channels[c][position] = data[c][i];
                c++;
              }
              position++;
              results.push(i++);
            }
            return results;
          };
          offline.oncomplete = function() {
            var channel, i, j, len;
            buffer = audio.createBuffer(numberOfChannels, channels[0].length, audio.sampleRate);
            for (i = j = 0, len = channels.length; j < len; i = ++j) {
              channel = channels[i];
              buffer.copyToChannel(channel, i);
            }
            return resolve(null);
          };
          osc.start(0);
          return offline.startRendering();
        });
      },
      renderEffect: function(effect, length, offset, wraptail) {
        var start, stop;
        length = length || buffer.length;
        start = 0;
        stop = length;
        if (offset) {
          start = Math.floor(offset * length);
          stop = start + length;
        }
        return new Promise(function(resolve) {
          var c, data, effectChain, offline, position, processor, stride;
          stride = 1024;
          offline = new OfflineAudioContext(buffer.numberOfChannels, stop + stride, buffer.sampleRate);
          processor = offline.createScriptProcessor(stride, buffer.numberOfChannels, buffer.numberOfChannels);
          source = offline.createBufferSource();
          if (start > 0) {
            source.loop = true;
          }
          effectChain = effect(offline);
          source.connect(effectChain);
          effectChain.connect(processor);
          processor.connect(offline.destination);
          channels = [];
          data = [];
          c = 0;
          while (c++ < buffer.numberOfChannels) {
            channels.push(new Float32Array(length));
            data.push(new Float32Array(stride));
          }
          position = 0;
          processor.onaudioprocess = function(e) {
            var i, results;
            c = 0;
            while (c < buffer.numberOfChannels) {
              data[c] = e.inputBuffer.getChannelData(c);
              c++;
            }
            i = 0;
            results = [];
            while (i < data[0].length) {
              c = 0;
              while (c < buffer.numberOfChannels) {
                if ((start <= position && position < stop)) {
                  channels[c][position - start] = data[c][i];
                }
                c++;
              }
              position++;
              results.push(i++);
            }
            return results;
          };
          offline.oncomplete = function() {
            var channel, i, j, len;
            //sort out channels
            if (start > 0) {
              //move last {start} samples from the end to the front
              c = 0;
              while (c < buffer.numberOfChannels) {
                channels[c] = new Float32Array([...channels[c].slice(channels[c].length - start), ...channels[c].slice(0, channels[c].length - start)]);
                c++;
              }
            }
            buffer = audio.createBuffer(channels.length, channels[0].length, audio.sampleRate);
            for (i = j = 0, len = channels.length; j < len; i = ++j) {
              channel = channels[i];
              buffer.copyToChannel(channel, i);
            }
            return resolve(null);
          };
          source.buffer = buffer;
          source.start(0);
          return offline.startRendering();
        });
      },
      renderRms: async function(rmsWav) {
        var c, data, i, results, rms0, rms1, rmsChannel, rmsIndex, rmsRatio, rmsVal, rmsWavData, stride;
        await rmsWav.analyze();
        rmsWavData = rmsWav.getRmsData();
        c = 0;
        stride = 256;
        data = new Float32Array(buffer.length);
        results = [];
        while (c < buffer.numberOfChannels) {
          buffer.copyFromChannel(data, c);
          rmsChannel = rmsWavData[Math.min(c, rmsWavData.length - 1)];
          i = 0;
          while (i < buffer.length) {
            rmsIndex = Math.floor(i / stride);
            rmsRatio = (i % stride) / stride;
            rms0 = rmsChannel[rmsIndex % rmsChannel.length] || 0;
            rms1 = rmsChannel[(rmsIndex + 1) % rmsChannel.length] || 0;
            rmsVal = rms1 + (rms0 - rms1) * rmsRatio;
            data[i] = data[i] * rmsVal;
            i++;
          }
          buffer.copyToChannel(data, c);
          results.push(c++);
        }
        return results;
      },
      renderScript: async function(instructions, seed, _fileName) {
        var all, args, arrs, bfile, c, cbuffer, data, i, impulse, impulseName, instruction, j, len, mix, mixarrs, mywav, name, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, results, rmsWav, start, value, waveform;
        waveform = this;
        mixarrs = waveform.extractRegion(0, buffer.length);
        mix = 0;
        fileName = fileName || _fileName;
        for (j = 0, len = instructions.length; j < len; j++) {
          instruction = instructions[j];
          if (!instruction) {
            continue;
          }
          if (/mix/.test(instruction)) {
            [, value] = instruction.match(/mix (.*)/);
            try {
              value = +value;
              mix = value / 100;
            } catch (error) {}
          } else if (/extract/.test(instruction)) {
            regions = waveform.getRegions();
            if (typeof ProjectManager !== "undefined" && ProjectManager !== null) {
              if ((ref = ProjectManager.getProject()) != null) {
                ref.regions[fileName] = [];
              }
            }
            i = 0;
            while (i < regions.length) {
              start = i === 0 ? 0 : regions[i - 1];
              if (regions[i] - start > 100) {
                try {
                  arrs = waveform.extractRegion(start, regions[i]);
                  mywav = (await Waveform(audio).fromArray(arrs));
                  if (typeof ProjectManager !== "undefined" && ProjectManager !== null) {
                    if ((ref1 = ProjectManager.getProject()) != null) {
                      ref1.regions[fileName].push({
                        start: start,
                        end: regions[i],
                        waveform: mywav
                      });
                    }
                  }
                } catch (error) {}
              }
              i++;
            }
          } else if (/convolve/.test(instruction)) {
            [, name] = instruction.match(/convolve (.*)/);
            impulseName = name; //if /\$/.test(name) then fileName + ':' + name else name
            cbuffer = (typeof ProjectManager !== "undefined" && ProjectManager !== null ? (ref2 = ProjectManager.getImpulses()) != null ? (ref3 = ref2[impulseName]) != null ? ref3.buffer : void 0 : void 0 : void 0) || (typeof ProjectManager !== "undefined" && ProjectManager !== null ? (ref4 = ProjectManager.getWaveforms()) != null ? (ref5 = ref4[name]) != null ? ref5.getBuffer() : void 0 : void 0 : void 0);
            if (!cbuffer) {
              bfile = files[Math.floor(noise.hash(seed++) * files.length)];
              impulse = (await Waveform(audio).fromFile(bfile));
              if (typeof ProjectManager !== "undefined" && ProjectManager !== null) {
                if ((ref6 = ProjectManager.getImpulses()) != null) {
                  ref6[impulseName] = {
                    name: bfile.name,
                    buffer: impulse.getBuffer()
                  };
                }
              }
              cbuffer = typeof ProjectManager !== "undefined" && ProjectManager !== null ? (ref7 = ProjectManager.getImpulses()) != null ? ref7[impulseName].buffer : void 0 : void 0;
            }
            await waveform.renderEffect(function(ctx) {
              var convolver;
              convolver = ctx.createConvolver();
              convolver.buffer = cbuffer;
              convolver.normalize = true;
              return convolver;
            }, waveform.getBuffer().length * 2);
          } else if (/renderRms/.test(instruction)) {
            [, name] = instruction.match(/renderRms (.*)/);
            rmsWav = typeof ProjectManager !== "undefined" && ProjectManager !== null ? (ref8 = ProjectManager.getWaveforms()) != null ? ref8[name] : void 0 : void 0;
            if (rmsWav) {
              await waveform.renderRms(rmsWav);
            }
          } else if (/->/.test(instruction)) {
            await waveform.renderEffect(function(ctx) {
              var conn, dest, effects, ref9;
              dest = null;
              conn = null;
              effects = [];
              effects = instruction.split(/ *-> */g).map(function(item, i) {
                var all, args, effect, key, ref10, ref9, val;
                if (item === 'render') {
                  return null;
                }
                [all, name, args] = item.match(/(.*?)\((.*?)\)/);
                args = args.replace(/:[ *]duration(.*?)(,|\})/g, function(all, dur) {
                  var val;
                  val = eval(waveform.getBuffer().duration + dur);
                  return ':' + val + ',';
                });
                args = JSON.parse(args);
                if (window[name]) {
                  args.audio = ctx;
                  effect = window[name](args);
                }
                if (ctx['create' + name]) {
                  effect = ctx['create' + name]();
                  for (key in args) {
                    val = args[key];
                    if (typeof val === 'string') {
                      effect[key] = val;
                    } else {
                      effect[key].value = val;
                    }
                  }
                }
                if (((ref9 = effects[i - 1]) != null ? ref9.gain : void 0) || ((ref10 = effects[i - 1]) != null ? ref10.connect : void 0)) {
                  (effects[i - 1].gain || effects[i - 1]).connect(effect.gain || effect);
                }
                conn = conn || effect;
                dest = effect;
                return effect;
                return item;
              });
              if ((ref9 = conn.gain) != null ? ref9.connect : void 0) {
                return conn.gain;
              } else {
                return conn;
              }
            });
          } else {
            [all, name, args] = instruction.match(/(.*?)\((.*?)\)/);
            if (args) {
              args = args.split(/, */).map(function(item) {
                return +(item.trim());
              });
            }
            try {
              await waveform[name].call(this, args);
            } catch (error) {}
          }
        }
        if (mix > 0) {
          c = 0;
          data = new Float32Array(buffer.length);
          results = [];
          while (c < buffer.numberOfChannels) {
            buffer.copyFromChannel(data, c);
            i = 0;
            while (i < buffer.length) {
              if (i < mixarrs[c].length) {
                data[i] = (data[i] * mix) + (mixarrs[c][i] * (1 - mix));
              } else {
                data[i] = data[i] * mix;
              }
              i++;
            }
            buffer.copyToChannel(data, c);
            results.push(c++);
          }
          return results;
        }
      },
      resize: function(factor) {
        var newLength;
        newLength = Math.floor(buffer.length * factor);
        return new Promise(function(resolve) {
          var offline;
          offline = new OfflineAudioContext(buffer.numberOfChannels, newLength, buffer.sampleRate);
          source = offline.createBufferSource();
          source.connect(offline.destination);
          source.buffer = buffer;
          source.playbackRate.value = 1 / factor;
          offline.oncomplete = function(e) {
            buffer = e.renderedBuffer;
            return resolve(null);
          };
          source.start(0);
          return offline.startRendering();
        });
      },
      fillBins: function() {
        var binNo, c, data, i, length, results, start, stop;
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
        channels = [];
        start = Math.floor(view.start * buffer.length);
        stop = Math.floor(view.stop * buffer.length);
        length = stop - start;
        c = 0;
        data = new Float32Array(buffer.length);
        results = [];
        while (c < buffer.numberOfChannels) {
          buffer.copyFromChannel(data, c);
          channels[c] = channels[c] || [];
          i = start;
          while (i <= stop) {
            binNo = Math.floor((i - start) / length * canvas.width);
            channels[c][binNo] = channels[c][binNo] || [1, -1];
            channels[c][binNo][0] = Math.min(data[i], channels[c][binNo][0]);
            channels[c][binNo][1] = Math.max(data[i], channels[c][binNo][1]);
            i++;
          }
          results.push(c++);
        }
        return results;
      },
      setView: function(start, stop) {
        view.start = start;
        return view.stop = stop;
      },
      getView: function() {
        return view;
      },
      draw: function() {
        var bin, c, channel, channelHeight, channelY, ctx, i, j, k, len, len1, results;
        ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        channelHeight = canvas.height / channels.length / 2;
        results = [];
        for (c = j = 0, len = channels.length; j < len; c = ++j) {
          channel = channels[c];
          ctx.beginPath();
          ctx.strokeStyle = 'black';
          channelY = channelHeight * 2 * c + channelHeight;
          ctx.moveTo(0, (channel[0][0] * channelHeight) + channelY);
          for (i = k = 0, len1 = channel.length; k < len1; i = ++k) {
            bin = channel[i];
            if (!bin) {
              continue;
            }
            ctx.lineTo(i, (bin[0] * channelHeight) + channelY);
            if (bin[0] !== bin[1]) {
              ctx.lineTo(i, (bin[1] * channelHeight) + channelY);
            }
          }
          results.push(ctx.stroke());
        }
        return results;
      },
      drawFrequencyData: function() {
        var ctx, data, frame, j, len, noFreqs, results, sqHeight, sqWidth, x, y;
        ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        noFreqs = frequencyData[0].length;
        sqHeight = canvas.height / noFreqs;
        sqWidth = canvas.width / frequencyData.length;
        results = [];
        for (x = j = 0, len = frequencyData.length; j < len; x = ++j) {
          frame = frequencyData[x];
          results.push((function() {
            var k, len1, results1;
            results1 = [];
            for (y = k = 0, len1 = frame.length; k < len1; y = ++k) {
              data = frame[y];
              ctx.beginPath();
              ctx.fillStyle = 'rgba(0, ' + data + ', 0, 1)';
              ctx.lineWidth = 0;
              results1.push(ctx.fillRect(x * sqWidth, canvas.height - (y * sqHeight), sqWidth * 2, sqHeight * 2));
            }
            return results1;
          })());
        }
        return results;
      },
      drawRegions: function() {
        var ctx, j, len, r, results, rx;
        ctx = canvas.getContext('2d');
        results = [];
        for (j = 0, len = regions.length; j < len; j++) {
          r = regions[j];
          rx = Math.floor(r / buffer.length * canvas.width);
          ctx.beginPath();
          ctx.strokeStyle = 'red';
          ctx.moveTo(rx, 0);
          ctx.lineTo(rx, canvas.height);
          results.push(ctx.stroke());
        }
        return results;
      },
      setCanvas: function(_canvas) {
        return canvas = _canvas;
      },
      getBuffer: function() {
        return buffer;
      },
      getRegions: function() {
        return regions;
      },
      getRmsData: function() {
        return rmsData;
      },
      findZeroCrossing: function(position) {},
      extractRegion: function(start, stop, channel) {
        var arr, arrs, c, data, i;
        arrs = [];
        c = 0;
        data = new Float32Array(buffer.length);
        while (c < buffer.numberOfChannels) {
          if (typeof channel === 'number' && c !== channel) {
            c++;
            continue;
          }
          arr = new Float32Array(stop - start);
          buffer.copyFromChannel(data, c);
          i = start;
          while (i < stop) {
            arr[i - start] = data[i];
            i++;
          }
          arrs.push(arr);
          c++;
        }
        return arrs;
      },
      fromWaveform: async function(_waveform) {
        var arrs;
        arrs = _waveform.extractRegion(0, _waveform.getBuffer().length);
        return (await this.fromArray(arrs));
      },
      fromArray: function(arrs) {
        var self;
        self = this;
        return new Promise(function(resolve) {
          var arr, i, j, len;
          buffer = audio.createBuffer(arrs.length, arrs[0].length, audio.sampleRate);
          for (i = j = 0, len = arrs.length; j < len; i = ++j) {
            arr = arrs[i];
            buffer.copyToChannel(arr, i);
          }
          return resolve(self);
        });
      },
      fromFile: function(file) {
        var self;
        fileName = file.name;
        self = this;
        return new Promise(function(resolve) {
          var reader;
          reader = new FileReader();
          reader.onload = function(e) {
            return audio.decodeAudioData(reader.result, function(_buffer) {
              buffer = _buffer;
              return resolve(self);
            });
          };
          return reader.readAsArrayBuffer(file);
        });
      },
      fromGraph: async function(_graph, multiplier, offset, tempo, beats) {
        var graph, i, length, nosmps, oversample, oversampled;
        oversample = 1;
        graph = (await Graph.fromGraph(_graph, multiplier, offset, tempo, beats));
        length = graph.getBeats() * (60 / graph.getTempo());
        nosmps = +length * audio.sampleRate * oversample;
        oversampled = new Float32Array(nosmps);
        i = 0;
        while (i < nosmps) {
          oversampled[i] = (await graph.getValue(i / nosmps));
          i++;
        }
        /*
        oswaveform = await Waveform(audio).fromArray [oversampled]
        await oswaveform.renderEffect (ctx) ->
          filter = ctx.createBiquadFilter()
          filter.type = 'lowpass'
          filter.frequency = ctx.sampleRate / oversample
          filter
        , null, 0.1
        [oversampled] = oswaveform.extractRegion 0, oswaveform.getBuffer().length
        i = 0
        arr = new Float32Array(+length * audio.sampleRate)
        currentVal = 0
        currentPos = 0
        while i < nosmps
          if Math.floor(i / oversample) isnt currentPos
            arr[currentPos] = currentVal /oversample
            currentPos++
            currentVal = 0
          currentVal += oversampled[i]
          i++
        arr[currentPos] = currentVal / oversample
        */
        return (await Waveform(audio).fromArray([oversampled]));
      },
      toBase64: function() {
        return URL.createObjectURL(FileUtils.bufferToWave(buffer));
      },
      toWave: function() {
        return FileUtils.bufferToWave(buffer);
      },
      play: function(dest, isloop) {
        if (source) {
          source.stop();
          source = null;
        }
        source = audio.createBufferSource();
        source.buffer = buffer;
        if (isloop) {
          source.loop = true;
        }
        source.connect(dest || audio.destination);
        return source.start();
      },
      stop: function() {
        if (source) {
          source.stop();
          return source = null;
        }
      },
      getFrequencyData: function() {
        return frequencyData;
      },
      getPitchData: function() {
        return pitchData;
      },
      getChannelData: function() {
        return channels;
      },
      getValueAtTime: function(time) {
        var c, channelData, channelFrac, channelIndex, channelTime, data0, data1, output, val;
        time = time % 1;
        output = [];
        c = 0;
        while (c < buffer.numberOfChannels) {
          channelData = buffer.getChannelData(c);
          channelTime = channelData.length * time;
          channelIndex = Math.floor(channelTime);
          channelFrac = channelTime - Math.trunc(channelTime);
          data0 = channelData[channelIndex];
          if (channelIndex < channelData.length) {
            data1 = channelData[channelIndex + 1];
          } else {
            data1 = data0;
          }
          val = data0 + (data1 - data0) * channelFrac;
          output.push(val);
          c++;
        }
        return output;
      },
      getRmsAtTime: function(time) {
        var c, channelData, channelFrac, channelIndex, channelTime, data0, data1, output, val;
        time = time % 1;
        output = [];
        c = 0;
        while (c < rmsData.length) {
          channelData = rmsData[c];
          channelTime = channelData.length * time;
          channelIndex = Math.floor(channelTime);
          channelFrac = channelTime - Math.trunc(channelTime);
          data0 = channelData[channelIndex];
          if (channelIndex < channelData.length) {
            data1 = channelData[channelIndex + 1];
          } else {
            data1 = data0;
          }
          val = data0 + (data1 - data0) * channelFrac;
          output.push(val);
          c++;
        }
        return output;
      }
    };
  };

  window.Waveform = Waveform;

  module.exports = Waveform;

}).call(this);
