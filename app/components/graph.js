// Generated by CoffeeScript 2.5.1
(function() {
  var Graph, Notes, ProjectManager, Waveform, atob, noise, waveTables, waveforms;

  waveTables = {};

  waveforms = {};

  Notes = require('./notes');

  noise = require('./noise');

  atob = function(str) {
    return Buffer.from(str, 'base64').toString();
  };

  Waveform = function(data) {
    return {
      getRegions: function() {
        return data.regions;
      },
      getBuffer: function() {
        return {
          length: data.buffer[0].length
        };
      },
      getValueAtTime: function(time) {
        var c, channelData, channelFrac, channelIndex, channelTime, data0, data1, output, val;
        time = time % 1;
        output = [];
        c = 0;
        while (c < data.buffer.length) {
          channelData = data.buffer[c];
          channelTime = channelData.length * time;
          channelIndex = Math.floor(channelTime);
          channelFrac = channelTime - Math.trunc(channelTime);
          data0 = channelData[channelIndex];
          if (channelIndex < channelData.length) {
            data1 = channelData[channelIndex + 1];
          } else {
            data1 = data0;
          }
          val = data0 + (data1 - data0) * channelFrac;
          output.push(val);
          c++;
        }
        return output;
      },
      getRmsAtTime: function(time) {
        var c, channelData, channelFrac, channelIndex, channelTime, data0, data1, output, val;
        time = time % 1;
        output = [];
        c = 0;
        while (c < data.rmsData.length) {
          channelData = data.rmsData[c];
          channelTime = channelData.length * time;
          channelIndex = Math.floor(channelTime);
          channelFrac = channelTime - Math.trunc(channelTime);
          data0 = channelData[channelIndex];
          if (channelIndex < channelData.length) {
            data1 = channelData[channelIndex + 1];
          } else {
            data1 = data0;
          }
          val = data0 + (data1 - data0) * channelFrac;
          output.push(val);
          c++;
        }
        return output;
      }
    };
  };

  ProjectManager = {
    getWaveforms: function() {
      return waveforms;
    }
  };

  Graph = function(text = 'return x', multiplier = 1, offset = 0, range = {
      "h": [0, 1],
      "v": [-0.1, 1.1]
    }, tempo = 60, beats = 1) {
    var analyzeWaveform, audio, barNo, canvas, filterData, fn, hash, innerfn, loadAudioFile, loadWaveTable, notes, preDone, storage, time, util;
    noise.reset();
    canvas = null;
    time = 0;
    barNo = 0;
    audio = null;
    filterData = {};
    notes = {};
    loadAudioFile = async function(file) {
      audio = audio || new AudioContext();
      if (waveforms[file.name]) {
        return;
      }
      return waveforms[file.name] = (await Waveform(audio).fromFile(file));
    };
    loadWaveTable = async function(name) {
      var data, response, waveform;
      audio = audio || new AudioContext();
      if (waveTables[name]) {
        return;
      }
      response = (await fetch('https://ndxbxrme.github.io/yma-full/assets/wave-tables/' + name));
      data = JSON.parse(((await response.text())).replace(/'/g, '"').replace(/\n/g, '').replace(/,\]/g, ']').replace(/,\}/g, '}'));
      waveTables[name] = audio.createPeriodicWave(data.real, data.imag);
      waveform = Waveform(audio);
      await waveform.renderOscillator(function(ctx) {
        var osc;
        osc = ctx.createOscillator();
        osc.frequency.value = 1;
        osc.setPeriodicWave(waveTables[name]);
        return osc;
      }, audio.sampleRate);
      return waveforms[name] = waveform;
    };
    analyzeWaveform = async function(name) {
      var ref;
      if ((ref = ProjectManager.getWaveforms()[name].getRmsData()) != null ? ref.length : void 0) {
        return;
      }
      return (await ProjectManager.getWaveforms()[name].analyze());
    };
    hash = function(str) {
      var h, i;
      h = 5381;
      i = str.length;
      while (i) {
        h = (h * 33) ^ str.charCodeAt(--i);
      }
      return h;
    };
    preDone = false;
    storage = {};
    util = {
      preprocess: function(fn) {
        if (!preDone) {
          fn.call(this);
          return preDone = true;
        }
      },
      set: function(name, val) {
        return storage[name] = val;
      },
      get: function(name) {
        return storage[name];
      },
      f: function(freq, nobeats) {
        return freq * (60 / tempo) * (nobeats || beats);
      },
      wt: function(name, x) {
        return waveforms[name].getValueAtTime(x);
      },
      wf: function(name, x) {
        return ProjectManager.getWaveforms()[name].getValueAtTime(x);
      },
      graph: function(name, x) {
        return ProjectManager.getGraphs()[name].getValue(x);
      },
      rms: function(name, x) {
        return ProjectManager.getWaveforms()[name].getRmsAtTime(x);
      },
      makeNotes: function(name, mynotes, offset) {
        return notes[name] = notes[name] || Notes.byMIDINo.filter(function(note, i) {
          return mynotes.map(function(item) {
            return (item + offset) % 12;
          }).includes(i % 12);
        });
      },
      note: function(name, num) {
        return notes[name][num];
      },
      bc: function(x, num, len) {
        var ref;
        len = len || 8;
        return (ref = ((1 << Math.floor(len - x * len)) & num) > 0) != null ? ref : {
          1: 0
        };
      },
      ws: function(x) {
        return 1.5 * x - 0.5 * Math.pow(x, 3);
      },
      clamp: function(x, min, max) {
        return Math.min(max, Math.max(min, x));
      },
      ramp: function(x) {
        x = x % 1;
        return x;
      },
      scurve: function(x, factor) {
        var k;
        x = x * 2 / 1 - 1;
        k = factor || 10;
        return .5 + (3 + k) * x * 28.7 * (Math.PI / 180) / (Math.PI + k * Math.abs(x));
      },
      seq: function(x, beats, steps, fn) {
        var cell, count, ison, nosteps, start, steplength, stepx;
        nosteps = beats * steps;
        steplength = 1 / steps;
        x *= beats;
        cell = Math.floor(x * steps);
        x %= steplength;
        stepx = x * steps;
        start = cell;
        count = 0;
        ison = fn(cell);
        while ((!ison) && (count < nosteps)) {
          start--;
          if (start < 0) {
            start = nosteps - 1;
          }
          ison = fn(start);
          count++;
        }
        x = x + count * steplength;
        return [Math.min(1, Math.max(0, x > 1 ? 0 : x)), cell - count < 0 ? cell - count + nosteps : cell - count, Math.min((fn(cell + 1) ? this.clamp((1 - stepx) * 100, 0, 1) : 1), (cell === start ? Math.min(x * 1000, 1) : 1)), x < .1];
      },
      adr: function(x, a, d, r) {
        return this.clamp(Math.pow(1 - (x - d), r), 0, 1) * Math.sin((this.clamp(x, 0, a)) * Math.PI * 2 * 1 / a * .25);
      },
      adsr: function(x, at, dt, dv, st, sv, rt) {
        var curve;
        curve = function(x, from, to) {
          return (.5 + .5 * Math.sin((x * .5 + .25) * Math.PI * 2)) * (to - from) + from;
        };
        return (x < at && curve(x * 1 / at, 1, 0)) || (x >= at && x < at + dt && curve((x - at) * 1 / dt, dv, 1)) || (x >= at + dt && x < at + dt + st && curve((x - (at + dt)) * 1 / st, sv, dv)) || (x >= at + dt + st && x <= at + dt + st + rt && curve((x - (at + dt + st)) * 1 / rt, 0, sv));
      },
      gs: function(name, x, multiplier, offset) {
        var allx, jig, out, x1;
        x %= 1;
        x1 = x + .5;
        x1 %= 1;
        allx = x;
        jig = this.clamp((x - .4) * 10, 0, 1) * this.clamp((1 - x) * 10, 0, 1);
        x *= multiplier;
        x1 *= multiplier;
        x += offset;
        x1 += offset;
        out = this.wf(name, x1)[0] * (1 - jig);
        out += this.wf(name, x)[0] * jig;
        return out;
      },
      region: function(name, x, regionNo) {
        var length, region, regions, rend, rlen, rstart, val, wf;
        x %= 1;
        wf = ProjectManager.getWaveforms()[name];
        regions = wf.getRegions();
        length = wf.getBuffer().length;
        regionNo = regionNo % regions.length;
        region = regions[regionNo];
        rstart = region.start / length;
        //console.log 'rst', rstart, length
        rend = region.end / length;
        rlen = rend - rstart;
        //console.log rstart, rend, rlen
        //console.log 'r', x, @clamp((rlen - x) * 100, 0, 1)
        val = wf.getValueAtTime(x + rstart);
        return val.map((item) => {
          return item; // * @clamp((rlen - x) * 100, 0, 1)
        });
      },
      draw: function() {
        return 0;
      }
    };
    innerfn = new Function("x,noise,util,seed,time,barNo,notesByMIDINo,notesByName", text);
    fn = function(_multiplier = multiplier, _offset = offset) {
      return function(x, noise, util, seed, time, barNo, notesByMIDINo, notesByName) {
        return innerfn(x, noise, util, seed, time, barNo, notesByMIDINo, notesByName) * +_multiplier + +_offset;
      };
    };
    return {
      /*
      wavetablesToLoad = (text.match(/wt\(\s*['"].*?['"]/g) or []).map((item) -> item.replace(/wt\(\s*|['"]/g, ''))
      if wavetablesToLoad.length
        for wavetableName in wavetablesToLoad
          await loadWaveTable wavetableName
      waveformsToAnalyze = (text.match(/(rms|region)\([\sx,]*['"].*?['"]/g) or []).map((item) -> item.replace(/(rms|region)\([\sx,]*|['"]/g, ''))
      console.log 'waveformsToAnalyze', waveformsToAnalyze
      if waveformsToAnalyze.length
        for waveformName in waveformsToAnalyze
          await analyzeWaveform waveformName
      */
      fn: fn,
      setCanvas: function(_canvas) {
        return canvas = _canvas;
      },
      setTime: function(_time) {
        return time = _time;
      },
      setBarNo: function(_barNo) {
        return barNo = _barNo;
      },
      getText: function() {
        return text;
      },
      getMultiplier: function() {
        return multiplier;
      },
      getOffset: function() {
        return offset;
      },
      getRange: function() {
        return range;
      },
      getTempo: function() {
        return tempo;
      },
      getBeats: function() {
        return beats;
      },
      getValue: function(x) {
        return fn()(x, noise, util, 200, time, barNo, Notes.byMIDINo, Notes.byName);
      },
      toBase64: function() {
        return btoa(JSON.stringify({
          text: text,
          multiplier: multiplier,
          offset: offset,
          range: range,
          tempo: tempo,
          beats: beats
        }));
      },
      draw: function() {
        var ctx, grd, maxY, minY, myx, myy, ref, x, y;
        canvas.width = canvas.offsetWidth;
        ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        myx = 0;
        ctx.beginPath();
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 2;
        minY = Number.MAX_SAFE_INTEGER;
        maxY = Number.MIN_SAFE_INTEGER;
        while (myx <= canvas.width) {
          x = myx / canvas.width * (range.h[1] - range.h[0]) + range.h[0];
          y = fn()(x, noise, util, 200, time, Notes.byMIDINo, Notes.byName);
          minY = Math.min(minY, y);
          maxY = Math.max(maxY, y);
          myy = canvas.height - (y - range.v[0]) / (range.v[1] - range.v[0]) * canvas.height;
          ctx[myx === 0 ? 'moveTo' : 'lineTo'](myx, myy);
          myx++;
        }
        ctx.lineTo(canvas.width + 10, canvas.height + 10);
        ctx.lineTo(-10, canvas.height + 10);
        ctx.lineTo(0, fn(x, window.noise, 200));
        grd = ctx.createLinearGradient(0, 0, 0, 200);
        grd.addColorStop(0, 'lightblue');
        grd.addColorStop(1, 'white');
        ctx.fillStyle = grd;
        ctx.fill();
        ctx.stroke();
        return (ref = $('.minmax')) != null ? ref.innerText = 'min:' + minY.toFixed(3) + ', max:' + maxY.toFixed(3) : void 0;
      },
      loadAudioFile: loadAudioFile,
      setWaveforms: function(wfs) {
        var results, wf, wfName;
        results = [];
        for (wfName in wfs) {
          wf = wfs[wfName];
          results.push(waveforms[wfName] = Waveform(wf));
        }
        return results;
      }
    };
  };

  Graph.fromBase64 = async function(b64) {
    var data;
    data = JSON.parse(atob(b64));
    return (await Graph(data.text, data.multiplier, data.offset, data.range, data.tempo || 60, data.beats || 1));
  };

  Graph.fromGraph = async function(graph, multiplier, offset, tempo, beats) {
    //data = graph.toBase64()
    return (await Graph(graph.getText(), multiplier || graph.getMultiplier(), offset || graph.getOffset(), graph.getRange(), tempo || (graph.getTempo() || 60), beats || (graph.getBeats() || 1)));
  };

  Graph.getWaveforms = function() {
    return waveforms;
  };

  
  //window.Graph = Graph
  module.exports = Graph;

}).call(this);
