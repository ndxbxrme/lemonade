// Generated by CoffeeScript 2.5.1
(function() {
  var Filter, LOG_10, LOG_2, MAX_FILTER_STAGES, PI, SAMPLE_RATE, dB2rap, filterTypes, rap2dB;

  MAX_FILTER_STAGES = 5;

  SAMPLE_RATE = 48000;

  LOG_2 = 0.693147181;

  PI = Math.PI;

  LOG_10 = 2.302585093;

  dB2rap = function(dB) {
    return Math.exp(db * LOG_10 / 20);
  };

  rap2dB = function(rap) {
    return 20 * Math.log(rap) / LOG_10;
  };

  filterTypes = ['lowpass', 'highpass', 'lowpass2', 'highpass2', 'bandpass', 'notch', 'peak', 'lowshelf', 'highshelf'];

  Filter = function(Ftype, Ffreq, Fq, Fstages, FsampleRate) {
    var abovenq, bufferSize, c, cleanup, computefiltercoefs, d, filterout, firsttime, freq, gain, i, needsinterpolation, oldabovenq, oldc, oldd, oldx, oldy, order, q, setfreq, setfreq_and_q, setgain, setq, setstages, settype, singlefilterout, stages, type, x, xd, y, yd;
    SAMPLE_RATE = SAMPLE_RATE || FsampleRate;
    type = filterTypes.indexOf(Ftype);
    if (type === -1) {
      return;
    }
    stages = Math.min(MAX_FILTER_STAGES, Fstages);
    freq = Ffreq;
    q = Fq;
    gain = 1.0;
    order = null;
    bufferSize = null;
    c = new Array(3);
    d = new Array(3);
    oldc = new Array(3);
    oldd = new Array(3);
    xd = new Array(3);
    yd = new Array(3);
    x = new Array(MAX_FILTER_STAGES + 1);
    y = new Array(MAX_FILTER_STAGES + 1);
    oldx = new Array(MAX_FILTER_STAGES + 1);
    oldy = new Array(MAX_FILTER_STAGES + 1);
    needsinterpolation = null;
    firsttime = 0;
    abovenq = 0;
    oldabovenq = 0;
    i = 0;
    while (i < 3) {
      oldc[i] = 0;
      oldd[i] = 0;
      c[i] = 0;
      d[i] = 0;
      i++;
    }
    cleanup = function() {
      i = 0;
      while (i < MAX_FILTER_STAGES + 1) {
        x[i] = {
          c1: 0,
          c2: 0
        };
        y[i] = {
          c1: 0,
          c2: 0
        };
        oldx[i] = x[i];
        oldy[i] = y[i];
        i++;
      }
      return needsinterpolation = 0;
    };
    setfreq = function(frequency) {
      var nyquistthresh, rap;
      if (frequency < 0.1) {
        frequency = 0.1;
      }
      rap = freq / frequency;
      if (rap < 1.0) {
        rap = 1.0 / rap;
      }
      oldabovenq = abovenq;
      abovenq = frequency > (SAMPLE_RATE / 2 - 100.0);
      nyquistthresh = abovenq ^ oldabovenq;
      if ((rap > 3.0) || (nyquistthresh !== 0)) {
        i = 0;
        while (i < 3) {
          oldc[i] = c[i];
          oldd[i] = d[i];
          i++;
        }
        while (i < MAX_FILTER_STAGES + 1) {
          oldx[i] = x[i];
          oldy[i] = y[i];
          i++;
        }
        if (firsttime === 0) {
          needsinterpolation = 1;
        }
      }
      freq = frequency;
      computefiltercoefs();
      return firsttime = 0;
    };
    setfreq_and_q = function(frequency, _q) {
      q = _q;
      return setfreq(frequency);
    };
    setq = function(_q) {
      q = _q;
      return computefiltercoefs();
    };
    settype = function(_type) {
      type = filterTypes.indexOf(_type);
      return computefiltercoefs();
    };
    setstages = function(_stages) {
      if (_stages >= MAX_FILTER_STAGES) {
        _stages = MAX_FILTER_STAGES - 1;
      }
      cleanup();
      return computefiltercoefs();
    };
    setgain = function(dBgain) {
      gain = dB2rap(dBgain);
      return computefiltercoefs();
    };
    computefiltercoefs = function() {
      var alpha, beta, cs, omega, sn, tmp, tmpgain, tmpq, zerocoefs;
      tmp = null;
      omega = null;
      sn = null;
      cs = null;
      alpha = null;
      beta = null;
      zerocoefs = 0;
      if (freq > (SAMPLE_RATE / 2 - 100.0)) {
        freq = SAMPLE_RATE / 2 - 100.0;
        zerocoefs = 1;
      }
      if (freq < 0.1) {
        freq = 0.1;
      }
      if (q < 0.0) {
        q = 0.0;
      }
      tmpq = null;
      tmpgain = null;
      if (stages === 0) {
        tmpq = q;
        tmpgain = gain;
      } else {
        tmpq = (q > 1.0 ? Math.pow(q, 1.0 / (stages + 1.0)) : q);
        tmpgain = Math.pow(gain, 1.0 / (stages + 1));
      }
      switch (type) {
        case 0: //  LPF 1 pole
          if (zerocoefs === 0) {
            tmp = Math.exp(-2.0 * PI * freq / SAMPLE_RATE);
          } else {
            tmp = 0.0;
          }
          c[0] = 1.0 - tmp;
          c[1] = 0.0;
          c[2] = 0.0;
          d[1] = tmp;
          d[2] = 0.0;
          return order = 1;
        case 1: //HPF 1 pole
          if (zerocoefs === 0) {
            tmp = Math.exp(-2.0 * PI * freq / SAMPLE_RATE);
          } else {
            tmp = 0.0;
          }
          c[0] = (1.0 + tmp) / 2.0;
          c[1] = -(1.0 + tmp) / 2.0;
          c[2] = 0.0;
          d[1] = tmp;
          d[2] = 0.0;
          return order = 1;
        case 2: //LPF 2 poles 
          if (zerocoefs === 0) {
            omega = 2 * PI * freq / SAMPLE_RATE;
            sn = Math.sin(omega);
            cs = Math.cos(omega);
            alpha = sn / (2 * tmpq);
            tmp = 1 + alpha;
            c[0] = (1.0 - cs) / 2.0 / tmp;
            c[1] = (1.0 - cs) / tmp;
            c[2] = (1.0 - cs) / 2.0 / tmp;
            d[1] = -2.0 * cs / tmp * (-1.0);
            d[2] = (1.0 - alpha) / tmp * (-1.0);
          } else {
            c[0] = 1.0;
            c[1] = 0.0;
            c[2] = 0.0;
            d[1] = 0.0;
            d[2] = 0.0;
          }
          return order = 2;
        case 3: //HPF 2 poles 
          if (zerocoefs === 0) {
            omega = 2 * PI * freq / SAMPLE_RATE;
            sn = Math.sin(omega);
            cs = Math.cos(omega);
            alpha = sn / (2 * tmpq);
            tmp = 1 + alpha;
            c[0] = (1.0 + cs) / 2.0 / tmp;
            c[1] = -(1.0 + cs) / tmp;
            c[2] = (1.0 + cs) / 2.0 / tmp;
            d[1] = -2.0 * cs / tmp * (-1.0);
            d[2] = (1.0 - alpha) / tmp * (-1.0);
          } else {
            c[0] = 0.0;
            c[1] = 0.0;
            c[2] = 0.0;
            d[1] = 0.0;
            d[2] = 0.0;
          }
          return order = 2;
        case 4: //BPF 2 poles 
          if (zerocoefs === 0) {
            omega = 2 * PI * freq / SAMPLE_RATE;
            sn = Math.sin(omega);
            cs = Math.cos(omega);
            alpha = sn / (2 * tmpq);
            tmp = 1 + alpha;
            c[0] = alpha / tmp * sqrt(tmpq + 1);
            c[1] = 0;
            c[2] = -alpha / tmp * sqrt(tmpq + 1);
            d[1] = -2.0 * cs / tmp * (-1.0);
            d[2] = (1.0 - alpha) / tmp * (-1.0);
          } else {
            c[0] = 0.0;
            c[1] = 0.0;
            c[2] = 0.0;
            d[1] = 0.0;
            d[2] = 0.0;
          }
          return order = 2;
        case 5: //NOTCH 2 poles 
          if (zerocoefs === 0) {
            omega = 2 * PI * freq / SAMPLE_RATE;
            sn = Math.sin(omega);
            cs = Math.cos(omega);
            alpha = sn / (2.0 * sqrt(tmpq));
            tmp = 1.0 + alpha;
            c[0] = 1.0 / tmp;
            c[1] = -2.0 * cs / tmp;
            c[2] = 1.0 / tmp;
            d[1] = -2.0 * cs / tmp * (-1.0);
            d[2] = (1 - alpha) / tmp * (-1);
          } else {
            c[0] = 1.0;
            c[1] = 0.0;
            c[2] = 0.0;
            d[1] = 0.0;
            d[2] = 0.0;
          }
          return order = 2;
        case 6: //PEAK (2 poles)
          if (zerocoefs === 0) {
            omega = 2 * PI * freq / SAMPLE_RATE;
            sn = Math.sin(omega);
            cs = Math.cos(omega);
            tmpq *= 3.0;
            alpha = sn / (2.0 * tmpq);
            tmp = 1.0 + alpha / tmpgain;
            c[0] = (1.0 + alpha * tmpgain) / tmp;
            c[1] = (-2.0 * cs) / tmp;
            c[2] = (1.0 - alpha * tmpgain) / tmp;
            d[1] = -2.0 * cs / tmp * (-1.0);
            d[2] = (1 - alpha / tmpgain) / tmp * (-1);
          } else {
            c[0] = 1.0;
            c[1] = 0.0;
            c[2] = 0.0;
            d[1] = 0.0;
            d[2] = 0.0;
          }
          return order = 2;
        case 7: //Low Shelf - 2 poles
          if (zerocoefs === 0) {
            omega = 2 * PI * freq / SAMPLE_RATE;
            sn = Math.sin(omega);
            cs = Math.cos(omega);
            tmpq = sqrt(tmpq);
            alpha = sn / (2 * tmpq);
            beta = sqrt(tmpgain) / tmpq;
            tmp = (tmpgain + 1.0) + (tmpgain - 1.0) * cs + beta * sn;
            c[0] = tmpgain * ((tmpgain + 1.0) - (tmpgain - 1.0) * cs + beta * sn) / tmp;
            c[1] = 2.0 * tmpgain * ((tmpgain - 1.0) - (tmpgain + 1.0) * cs) / tmp;
            c[2] = tmpgain * ((tmpgain + 1.0) - (tmpgain - 1.0) * cs - beta * sn) / tmp;
            d[1] = -2.0 * ((tmpgain - 1.0) + (tmpgain + 1.0) * cs) / tmp * (-1.0);
            d[2] = ((tmpgain + 1.0) + (tmpgain - 1.0) * cs - beta * sn) / tmp * (-1.0);
          } else {
            c[0] = tmpgain;
            c[1] = 0.0;
            c[2] = 0.0;
            d[1] = 0.0;
            d[2] = 0.0;
          }
          return order = 2;
        case 8: //High Shelf - 2 poles
          if (zerocoefs === 0) {
            omega = 2 * PI * freq / SAMPLE_RATE;
            sn = Math.sin(omega);
            cs = Math.cos(omega);
            tmpq = sqrt(tmpq);
            alpha = sn / (2 * tmpq);
            beta = sqrt(tmpgain) / tmpq;
            tmp = (tmpgain + 1.0) - (tmpgain - 1.0) * cs + beta * sn;
            c[0] = tmpgain * ((tmpgain + 1.0) + (tmpgain - 1.0) * cs + beta * sn) / tmp;
            c[1] = -2.0 * tmpgain * ((tmpgain - 1.0) + (tmpgain + 1.0) * cs) / tmp;
            c[2] = tmpgain * ((tmpgain + 1.0) + (tmpgain - 1.0) * cs - beta * sn) / tmp;
            d[1] = 2.0 * ((tmpgain - 1.0) - (tmpgain + 1.0) * cs) / tmp * (-1.0);
            d[2] = ((tmpgain + 1.0) - (tmpgain - 1.0) * cs - beta * sn) / tmp * (-1.0);
          } else {
            c[0] = 1.0;
            c[1] = 0.0;
            c[2] = 0.0;
            d[1] = 0.0;
            d[2] = 0.0;
          }
          return order = 2; //wrong type
        default:
          type = 0;
          return computefiltercoefs();
      }
    };
    singlefilterout = function(smp, x, y, c, d) {
      var y0;
      i = null;
      y0 = null;
      if (order === 1) {
        i = 0;
        while (i < bufferSize) {
          y0 = smp[i] * c[0] + x.c1 * c[1] + y.c1 * d[1];
          y.c1 = y0;
          x.c1 = smp[i];
          smp[i] = y0;
          i++;
        }
      }
      if (order === 2) {
        i = 0;
        while (i < bufferSize) {
          y0 = smp[i] * c[0] + x.c1 * c[1] + x.c2 * c[2] + y.c1 * d[1] + y.c2 * d[2];
          y.c2 = y.c1;
          y.c1 = y0;
          x.c2 = x.c1;
          x.c1 = smp[i];
          smp[i] = y0;
        }
        return i++;
      }
    };
    filterout = function(smp, bufferSize_) {
      var ismp;
      ismp = null;
      bufferSize = bufferSize_;
      i = null;
      if (needsinterpolation !== 0) {
        ismp = new Array(bufferSize);
        i = 0;
        while (i < bufferSize) {
          ismp[i] = smp[i];
          i++;
        }
        i = 0;
        while (i < stages + 1) {
          singlefilterout(ismp, oldx[i], oldy[i], oldc, oldd);
          i++;
        }
      }
      i = 0;
      while (i < stages + 1) {
        singlefilterout(smp, x[i], y[i], c, d);
        i++;
      }
      if (needsinterpolation !== 0) {
        i = 0;
        while (i < bufferSize) {
          x = i / bufferSize;
          smp[i] = ismp[i] * (1.0 - x) + smp[i] * x;
        }
      }
      ismp = null;
      return needsinterpolation = 0;
    };
    //late init
    cleanup();
    setfreq_and_q(Ffreq, Fq);
    firsttime = 1;
    d[0] = 0;
    return {
      setfreq: setfreq,
      setq: setq,
      setstages: setstages,
      setgain: setgain,
      filterout: filterout
    };
  };

  module.exports = Filter;

}).call(this);
