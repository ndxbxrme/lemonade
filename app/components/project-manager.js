// Generated by CoffeeScript 2.5.1
(function() {

  /*
  modalHtml = pug.render $('#modal-welcome').innerText.replace(/\n  /g,'\n')
  await modal.show modalHtml, (resolve, reject) ->
    ProjectManager.newProject = ->
      ProjectManager.new()
      resolve()
    ProjectManager.openZip = (fileElm) ->
      ProjectManager.chooseFile fileElm
      resolve()
  modal.hide()
  */
  var CodeMirror, Editor, ProjectManager, addFile, audio, clearFiles, editor, files, getProjectJSON, graphEditor, graphPlaying, graphTimeout, graphWaveform, graphs, impulses, init, load, modal, newFn, processor, project, pug, readTextFile, renderFileList, renderProject, renderRegionList, save, selectedFile, selectedGraph, selectedRegion, setDrawerState, setGraphPlaying, setState, state, waveforms;

  modal = require('./modal/modal.coffee');

  Editor = require('./editor.coffee');

  CodeMirror = require('codemirror');

  require('codemirror/mode/javascript/javascript');

  require('codemirror/addon/fold/foldcode');

  require('codemirror/addon/fold/foldgutter');

  require('codemirror/addon/fold/brace-fold');

  pug = require('pug');

  selectedFile = null;

  selectedRegion = null;

  selectedGraph = null;

  graphWaveform = null;

  graphPlaying = false;

  processor = null;

  files = [];

  waveforms = {};

  impulses = {};

  graphs = {};

  project = null;

  audio = null;

  editor = Editor();

  state = null;

  window.editor = editor;

  document.body.onclick = function() {
    audio = audio || new AudioContext();
    if (editor != null) {
      editor.setAudio(audio);
    }
    return typeof Brain !== "undefined" && Brain !== null ? Brain.setAudio(audio) : void 0;
  };

  readTextFile = function(blob) {
    return new Promise(function(resolve) {
      var reader;
      reader = new FileReader();
      reader.onload = function(e) {
        return resolve(e.target.result);
      };
      return reader.readAsText(blob);
    });
  };

  addFile = async function(file) {
    var addWaveform, pfile, prevfile;
    [prevfile] = files.filter(function(item) {
      return item.name === file.name;
    });
    if (prevfile) {
      return;
    }
    Object.defineProperty(file, 'name', {
      writable: true,
      value: file.name.replace(/\.wav/, '')
    });
    addWaveform = async function() {
      var pfile;
      waveforms[file.name] = (await Waveform(audio).fromFile(file));
      waveforms[file.name].setCanvas($('canvas.thumbnail'));
      waveforms[file.name].fillBins();
      waveforms[file.name].draw();
      [pfile] = project.files.filter(function(item) {
        return item.name === file.name;
      });
      console.log('pfile', pfile);
      return pfile != null ? pfile.b64 = $('canvas.thumbnail').toDataURL() : void 0;
    };
    if (project.filesLoaded) {
      files.push(file);
      project.files.push({
        name: file.name
      });
      return (await addWaveform());
    } else {
      [pfile] = project.files.filter(function(item) {
        return item.name === file.name;
      });
      if (pfile) {
        files.push(file);
        return (await addWaveform());
      }
    }
  };

  renderFileList = function() {
    var file, fileFilter, j, len, myfiles, results;
    $('.file-list').innerHTML = '';
    fileFilter = $('.file-filter select').value;
    myfiles = project.files.filter(function(item) {
      var ref;
      if (fileFilter === 'All') {
        return true;
      }
      return (ref = item.tags) != null ? ref.includes(fileFilter) : void 0;
    });
    results = [];
    for (j = 0, len = myfiles.length; j < len; j++) {
      file = myfiles[j];
      results.push($('.file-list').innerHTML += pug.render($('#file-item').innerText.replace(/\n  /g, '\n'), {
        pm: self,
        file: file
      }));
    }
    return results;
  };

  renderRegionList = function() {
    var j, len, ref, region, regions, results;
    if (!selectedFile) {
      return;
    }
    regions = project.regions[selectedFile];
    $('.region-list').innerHTML = '';
    ref = regions != null;
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      region = ref[j];
      results.push($('.region-list').innerHTML += pug.render($('#region-item').innerText.replace(/\n  /g, '\n'), {
        region: region
      }));
    }
    return results;
  };

  renderProject = function() {
    var elm, ref, val;
    for (elm in project) {
      val = project[elm];
      if ((ref = $('#' + elm)) != null) {
        ref.value = val;
      }
    }
    renderFileList();
    return ProjectManager.renderGraphList();
  };

  getProjectJSON = function() {
    var graph, j, key, len, mygraphs, myproject, ref, ref1, region, regions, val;
    regions = {};
    ref = project.regions;
    for (key in ref) {
      val = ref[key];
      regions[key] = [];
      for (j = 0, len = val.length; j < len; j++) {
        region = val[j];
        regions[key].push({
          start: region.start,
          end: region.end,
          duration: region.waveform.getBuffer().duration,
          pitchData: region.waveform.getPitchData()
        });
      }
    }
    mygraphs = {};
    for (key in graphs) {
      graph = graphs[key];
      mygraphs[key] = {
        b64: graph.toBase64(),
        tags: JSON.stringify(graph.tags)
      };
    }
    myproject = {
      id: ((ref1 = $('#id')) != null ? ref1.value : void 0) || Math.floor(Math.random() * 9999999).toString(36),
      files: project.files.map(function(item) {
        return {
          name: item.name,
          tags: item.tags
        };
      }),
      script: $('#script').value,
      name: $('#name').value,
      seed: +$('#seed').value,
      regions: regions,
      graphs: mygraphs
    };
    return myproject;
  };

  clearFiles = function() {
    waveforms = {};
    impulses = {};
    files = [];
    $('.graph-filter select').value = 'All';
    $('.file-filter select').value = 'All';
    editor.clearWaveform();
    return selectedGraph = null;
  };

  newFn = function() {
    clearFiles();
    graphs = {};
    project = {
      id: Math.floor(Math.random() * 9999999).toString(36),
      files: [],
      regions: {},
      script: 'normalize()\nanalyze()\nextract()',
      name: 'New project',
      seed: 260,
      filesLoaded: true
    };
    return renderProject();
  };

  load = async function() {
    var graph, name, ref;
    clearFiles();
    project = JSON.parse($('#io').value);
    graphs = {};
    ref = project.graphs;
    for (name in ref) {
      graph = ref[name];
      graphs[name] = (await Graph.fromBase64(graph.b64));
      graphs[name].tags = JSON.parse(graph.tags);
      graphs[name].name = name;
    }
    project.filesLoaded = !project.files || project.files.length === 0;
    return renderProject();
  };

  save = function() {
    var myproject;
    myproject = getProjectJSON();
    $('#id').value = myproject.id;
    $('#io').value = JSON.stringify(myproject);
    return localStorage.setItem('classifier:currentProject', JSON.stringify(myproject));
  };

  setState = function(newState) {
    newState = newState || state;
    document.body.className = document.body.className.replace(/ *haswaveform| *hasgraph/g, '');
    if (ProjectManager.hasWaveform()) {
      document.body.className += ' haswaveform';
    }
    if (ProjectManager.hasGraph()) {
      document.body.className += ' hasgraph';
    }
    document.body.className = document.body.className.replace(/ *\bstate\w+/g, '');
    document.body.className += ' state' + newState;
    return state = newState;
  };

  setDrawerState = function(newState) {
    document.body.className = document.body.className.replace(/ *\bdrawerstate\w+/g, '');
    return document.body.className += ' drawerstate' + newState;
  };

  graphEditor = null;

  init = function() {
    var myproject;
    myproject = localStorage.getItem('classifier:currentProject');
    if (myproject) {
      $('#io').value = myproject;
      load();
    } else {
      newFn();
    }
    setState('brain');
    setDrawerState('files');
    graphEditor = CodeMirror.fromTextArea($('.graph-editor .fn'), {
      mode: 'javascript',
      lineWrapping: true,
      lineNumbers: true,
      foldGutter: true,
      gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"]
    });
    //graphEditor.foldCode()
    graphEditor.on('change', this.renderGraph);
    return console.log(graphEditor);
  };

  graphTimeout = null;

  setGraphPlaying = function(_state) {
    var playing;
    playing = _state;
    if (typeof document !== "undefined" && document !== null) {
      document.body.className = document.body.className.replace(/ *graph-playing/g, '');
    }
    try {
      clearTimeout(graphTimeout);
    } catch (error) {}
    if (_state) {
      return typeof document !== "undefined" && document !== null ? document.body.className += ' graph-playing' : void 0;
    }
  };

  //setTimeout init
  ProjectManager = {
    setState: setState,
    saveWaveform: function(name, _waveform, tags) {
      var b64, pfile;
      waveforms[name] = _waveform;
      waveforms[name].setCanvas($('canvas.thumbnail'));
      waveforms[name].fillBins();
      waveforms[name].draw();
      b64 = $('canvas.thumbnail').toDataURL();
      [pfile] = project.files.filter(function(item) {
        return item.name === name;
      });
      if (pfile) {
        pfile.tags = tags;
        pfile.b64 = b64;
      } else {
        project.files.push({
          name: name,
          tags: tags,
          b64: b64
        });
      }
      renderFileList();
      return renderRegionList();
    },
    loadZip: async function(data) {
      var key, myfile, ref, ref1, text, u8, unloaded, zfile, zip;
      audio = audio || new AudioContext();
      clearFiles();
      zip = (await JSZip.loadAsync(data));
      ref = zip.files;
      for (key in ref) {
        zfile = ref[key];
        if (key === 'project.json') {
          u8 = (await zfile.async('blob'));
          text = (await readTextFile(u8));
          $('#io').value = text;
          load();
        }
      }
      ref1 = zip.files;
      for (key in ref1) {
        zfile = ref1[key];
        if (/\.wav$/.test(key)) {
          u8 = (await zfile.async('blob'));
          myfile = new File([u8], key);
          await addFile(myfile);
        }
      }
      [unloaded] = project.files.filter(function(item) {
        [myfile] = files.filter(function(itemf) {
          return itemf.name === item.name;
        });
        return !myfile;
      });
      project.filesLoaded = !unloaded;
      return renderFileList();
    },
    chooseFile: async function(fileElm) {
      var file, j, key, len, myfile, ref, ref1, ref2, text, u8, unloaded, zfile, zip;
      if (!fileElm.files || !fileElm.files.length) {
        return;
      }
      audio = audio || new AudioContext();
      if (/application\/.*zip.*/.test(fileElm.files[0].type)) {
        //modalHtml = pug.render $('#modal-load-zip').innerText.replace(/\n  /g,'\n')
        //result = await modal.show modalHtml, (resolve) ->
        //  ProjectManager.openZip = ->
        clearFiles();
        zip = (await JSZip.loadAsync(fileElm.files[0]));
        ref = zip.files;
        for (key in ref) {
          zfile = ref[key];
          if (key === 'project.json') {
            u8 = (await zfile.async('blob'));
            text = (await readTextFile(u8));
            $('#io').value = text;
            load();
          }
        }
        ref1 = zip.files;
        for (key in ref1) {
          zfile = ref1[key];
          if (/\.wav$/.test(key)) {
            u8 = (await zfile.async('blob'));
            myfile = new File([u8], key);
            await addFile(myfile);
          }
        }
      } else {
        ref2 = fileElm.files;
        //    resolve()
        //modal.hide()
        for (j = 0, len = ref2.length; j < len; j++) {
          file = ref2[j];
          await addFile(file);
        }
      }
      [unloaded] = project.files.filter(function(item) {
        [myfile] = files.filter(function(itemf) {
          return itemf.name === item.name;
        });
        return !myfile;
      });
      project.filesLoaded = !unloaded;
      return renderFileList();
    },
    //files = fileElm.files
    renderScript: async function() {
      var file, fileNo, frame, i, instructions, item, j, k, key, l, len, len1, len2, len3, m, max, min, postText, preText, ref, ref1, region, regionNo, regions, scriptText, seed, waveform;
      //render everything up to and including extract
      seed = +$('#seed').value;
      document.body.className = document.body.className.replace(/ *working/g, '') + ' working';
      scriptText = $('#script').value.trim();
      [preText, postText] = scriptText.split(/extract.*?\n/);
      if (postText) {
        preText += '\nextract()';
      }
      preText = preText.replace(/\n[ +]/g, '');
      if (postText) {
        postText = postText.replace(/\n[ +]/g, '');
      }
      instructions = preText.split('\n');
      for (fileNo = j = 0, len = files.length; j < len; fileNo = ++j) {
        file = files[fileNo];
        waveforms[file.name] = waveform = (await Waveform(audio).fromFile(file));
        await waveform.renderScript(instructions, seed, file.name);
        min = 9999999;
        max = -9999999;
        ref = waveform.getFrequencyData();
        for (i = k = 0, len1 = ref.length; k < len1; i = ++k) {
          frame = ref[i];
          for (l = 0, len2 = frame.length; l < len2; l++) {
            item = frame[l];
            min = Math.min(item, min);
            max = Math.max(item, max);
          }
        }
        //render everything after the extract line
        waveform.setCanvas($('canvas'));
        waveform.fillBins();
        waveform.draw();
      }
      //waveform.drawRegions()
      //render regions
      if (postText) {
        instructions = postText.split('\n');
        ref1 = project.regions;
        for (key in ref1) {
          regions = ref1[key];
          for (regionNo = m = 0, len3 = regions.length; m < len3; regionNo = ++m) {
            region = regions[regionNo];
            await region.waveform.renderScript(instructions, seed);
          }
        }
      }
      return document.body.className = document.body.className.replace(/ *working/g, '');
    },
    init: init,
    new: newFn,
    load: load,
    save: save,
    setWorking: function() {
      return document.body.className = document.body.className.replace(/ *working/g, '') + ' working';
    },
    clearWorking: function() {
      return document.body.className = document.body.className.replace(/ *working/g, '');
    },
    renderProject: renderProject,
    renderFileList: renderFileList,
    clearFiles: clearFiles,
    fileClass: function(fileName) {
      var className, file;
      className = '';
      [file] = files.filter(function(item) {
        return item.name === fileName;
      });
      if (file) {
        className += ' loaded';
      }
      if (fileName === selectedFile) {
        className += ' selected';
      }
      return className;
    },
    regionClass: function(region) {
      var className;
      className = '';
      if (region.start.toString() === (selectedRegion != null ? selectedRegion.toString() : void 0)) {
        return className += ' selected';
      }
    },
    selectFile: async function(fileName) {
      /*
      selectedRegion = null
      #copy to current waveform
      currentWaveform = await Waveform(audio).fromWaveform waveforms[selectedFile]
      currentWaveform.setCanvas $ 'canvas'
      currentWaveform.fillBins()
      currentWaveform.draw()
       */
      var mywav, pfile;
      try {
        editor.stop();
      } catch (error) {}
      try {
        this.stopGraph();
      } catch (error) {}
      selectedFile = fileName;
      [pfile] = project.files.filter(function(item) {
        return item.name === fileName;
      });
      mywav = (await Waveform(audio).fromWaveform(waveforms[selectedFile]));
      mywav.name = fileName;
      editor.selectWaveform(fileName, mywav, pfile != null ? pfile.tags : void 0);
      setState('waveform');
      renderFileList();
      return renderRegionList();
    },
    selectRegion: function(regionName) {
      var region;
      selectedRegion = regionName.innerText;
      [region] = project.regions[selectedFile].filter(function(item) {
        return item.start.toString() === selectedRegion;
      });
      if (region) {
        region.waveform.play();
      }
      return renderRegionList();
    },
    playSelectedFile: function() {
      return waveforms[selectedFile].play();
    },
    stop: function() {},
    doZip: async function() {
      var content, key, myproject, waveform, zip;
      zip = new JSZip();
      myproject = getProjectJSON();
      zip.file('project.json', JSON.stringify(myproject, null, '  '));
      for (key in waveforms) {
        waveform = waveforms[key];
        zip.file(key + '.wav', waveform.toWave());
      }
      content = (await zip.generateAsync({
        type: 'blob'
      }));
      return FileSaver.saveAs(content, 'lemonade-' + myproject.name + '.zip');
    },
    //processScript: processScript
    getProject: function() {
      return project;
    },
    getImpulses: function() {
      return impulses;
    },
    getWaveforms: function() {
      return waveforms;
    },
    getGraphs: function() {
      return graphs;
    },
    getFiles: function() {
      return files;
    },
    renderGraphList: function() {
      var graph, graphFilter, j, k, len, len1, mygraphs, results;
      $('.graph-list').innerHTML = '';
      graphFilter = $('.graph-filter select').value;
      mygraphs = Object.values(graphs).filter(function(item) {
        var ref;
        if (graphFilter === 'All') {
          return true;
        }
        return (ref = item.tags) != null ? ref.includes(graphFilter) : void 0;
      });
      for (j = 0, len = mygraphs.length; j < len; j++) {
        graph = mygraphs[j];
        console.log($('#graph-item').innerText.replace(/\n  /g, '\n'));
        $('.graph-list').innerHTML += pug.render($('#graph-item').innerText.replace(/\n  /g, '\n'), {
          pm: self,
          graph: graph.name
        });
      }
      results = [];
      for (k = 0, len1 = mygraphs.length; k < len1; k++) {
        graph = mygraphs[k];
        graph.setCanvas($('.graph-list #g_' + graph.name.replace(/[^\w_-]/g, 'xx') + ' canvas'));
        results.push(graph.draw());
      }
      return results;
    },
    renderGraphControls: function() {
      $('.graph-editor .name').value = selectedGraph.name || 'changeme';
      $('.graph-editor .range').value = JSON.stringify(selectedGraph.getRange()) || '{"h":[0,1],"v":[-1,1]}';
      $('.graph-editor .multiplier').value = selectedGraph.getMultiplier() || 1;
      $('.graph-editor .offset').value = selectedGraph.getOffset() || 0;
      $('.graph-editor .tempo').value = selectedGraph.getTempo() || 60;
      $('.graph-editor .beats').value = selectedGraph.getBeats() || 1;
      $('.graph-editor .fn').value = selectedGraph.getText() || 'return Math.sin(x * Math.PI * 2)';
      return graphEditor.setValue($('.graph-editor .fn').value);
    },
    renderGraph: async function() {
      var data, e, fnVal, ge, graph, graphChanged;
      graphChanged = true;
      ge = $('.graph-editor');
      if (!graphEditor.getValue()) {
        return;
      }
      if ((typeof event !== "undefined" && event !== null ? event.keyCode : void 0) === 17) {
        return;
      }
      try {
        fnVal = graphEditor.getValue(); //$('.fn', ge).value
        if (fnVal.length < 10) {
          throw 'errror';
        }
        data = JSON.parse(atob(fnVal));
        graph = (await Graph(data.text, data.multiplier, data.offset, data.range, data.tempo, data.beats));
        selectedGraph = graph;
        this.renderGraphControls();
      } catch (error) {
        e = error;
        try {
          graph = (await Graph(graphEditor.getValue(), $('.multiplier', ge).value, $('.offset', ge).value, JSON.parse($('.range', ge).value), $('.tempo', ge).value, $('.beats', ge).value));
        } catch (error) {
          ge = error;
          console.log('caught one', ge.message);
        }
      }
      graph.name = $('.name', ge).value;
      graph.setCanvas($('canvas', ge));
      try {
        graph.draw();
      } catch (error) {
        e = error;
        console.log('caught another', e.message);
      }
      return selectedGraph = graph;
    },
    newGraph: async function() {
      selectedGraph = (await Graph());
      this.renderGraphControls();
      this.renderGraph();
      return setState('graph');
    },
    saveGraph: function() {
      var name;
      name = $('.graph-editor .name').value;
      selectedGraph.name = name;
      selectedGraph.tags = Array.from(document.querySelectorAll('.graph-editor .tags option')).reduce(function(result, item) {
        if (item.selected) {
          result.push(item.innerText);
        }
        return result;
      }, []);
      graphs[name] = selectedGraph;
      return this.renderGraphList();
    },
    selectGraph: function(name) {
      try {
        editor.stop();
      } catch (error) {}
      try {
        this.stopGraph();
      } catch (error) {}
      selectedGraph = graphs[name];
      document.querySelectorAll('.graph-editor .tags option').forEach(function(item) {
        item.selected = false;
        if (selectedGraph.tags && selectedGraph.tags.includes(item.innerText)) {
          return item.selected = true;
        }
      });
      setState('graph');
      this.renderGraphControls();
      return this.renderGraph();
    },
    playGraph: function() {
      var length, nosmps, position, ref, stride;
      audio = audio || new AudioContext();
      length = selectedGraph.getBeats() * (60 / selectedGraph.getTempo());
      nosmps = +length * audio.sampleRate;
      stride = 1024;
      processor = processor || audio.createScriptProcessor(stride, 1, 1);
      processor.connect(audio.destination);
      position = +((ref = $('.graph-startpos')) != null ? ref.value : void 0) * nosmps;
      graphPlaying = true;
      processor.onaudioprocess = function(e) {
        var c, data, i, results;
        c = 0;
        results = [];
        while (c < 1) {
          data = e.outputBuffer.getChannelData(c);
          i = 0;
          while (i < stride) {
            data[i] = !graphPlaying ? 0 : selectedGraph.getValue((position++ % nosmps) / nosmps);
            i++;
          }
          results.push(c++);
        }
        return results;
      };
      return setGraphPlaying(true);
    },
    /*

    graphWaveform = if graphChanged then graphWaveform else await Waveform(audio).fromGraph selectedGraph
    graphChanged = false
    graphWaveform.play null, $('#graph-loop').checked
    setGraphPlaying true
    if not $('#graph-loop').checked
      length = selectedGraph.getBeats() * (60 / selectedGraph.getTempo()) * 1000
      graphTimeout = setTimeout ->
        setGraphPlaying false
      , length
    */
    stopGraph: function() {
      if (graphWaveform != null) {
        graphWaveform.stop();
      }
      graphPlaying = false;
      return setGraphPlaying(false);
    },
    renderGraphToWaveform: async function() {
      var b64, name;
      audio = audio || new AudioContext();
      graphWaveform = (await Waveform(audio).fromGraph(selectedGraph));
      graphWaveform.setCanvas($('canvas.thumbnail'));
      graphWaveform.fillBins();
      graphWaveform.draw();
      b64 = $('canvas.thumbnail').toDataURL();
      name = 'Graph_' + $('.graph-editor .name').value;
      project.files.push({
        name: name,
        b64: b64
      });
      waveforms[name] = graphWaveform;
      return renderFileList();
    },
    deleteWaveform: function(name) {
      name = name || editor.waveformName();
      console.log('deleting', name);
      project.files = project.files.filter(function(item) {
        return item.name !== name;
      });
      files = files.filter(function(item) {
        return item.name !== name;
      });
      console.log('w1', waveforms);
      delete waveforms[name];
      console.log('w2', waveforms);
      if (editor.waveformName() === name) {
        editor.clearWaveform();
        setState();
      }
      return renderFileList();
    },
    renameWaveform: function(oldname, newname) {
      var myfile, mywaveform;
      oldname = oldname || editor.waveformName();
      newname = newname || $('.waveditor .name').value;
      mywaveform = waveforms[oldname];
      [myfile] = project.files.filter(function(item) {
        return item.name === oldname;
      });
      project.files = project.files.filter(function(item) {
        return item.name !== oldname;
      });
      files = files.filter(function(item) {
        return item.name !== oldname;
      });
      delete waveforms[name];
      waveforms[newname] = mywaveform;
      mywaveform.name = newname;
      editor.selectWaveform(newname, mywaveform, myfile != null ? myfile.tags : void 0);
      project.files.push({
        name: newname
      });
      return renderFileList();
    },
    deleteGraph: function(name) {
      name = name || selectedGraph.name;
      delete graphs[name];
      if (selectedGraph.name === name) {
        selectedGraph = null;
        setState();
      }
      renderFileList();
      return this.renderGraphList();
    },
    renameGraph: function(oldname, newname) {
      var mygraph;
      oldname = oldname || selectedGraph.name;
      newname = newname || $('.graph-editor .name').value;
      mygraph = graphs[oldname];
      delete graphs[oldname];
      graphs[newname] = mygraph;
      mygraph.name = newname;
      this.renderGraphList();
      return this.renderGraphControls();
    },
    hasGraph: function() {
      return selectedGraph !== null;
    },
    clearGraph: function() {
      selectedGraph = null;
      return setState();
    },
    hasWaveform: function() {
      return editor.hasWaveform();
    },
    clearWaveform: function() {
      editor.clearWaveform();
      return setState();
    },
    currentWaveform: function() {
      return editor.currentWaveform();
    },
    setState: setState,
    setDrawerState: setDrawerState,
    setSeed: function(_seed) {
      return project.seed = _seed;
    }
  };

  window.ProjectManager = ProjectManager;

  module.exports = ProjectManager;

}).call(this);
